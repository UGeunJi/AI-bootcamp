#### 배열은 데이터 구조의 하나로, 데이터를 1열로 나열한 것입니다. 앞 절의 리스트와는 대조적으로 데이터의 접근하기는 쉽지만 추가나 삭제에 시간이 걸립니다. 이것은 1-1절에서 설정한 가나다순의 전화번호부와 비슷한 구조입니다.

1. 배열의 개념도입니다. 세 개의 문자열 'Blue', 'Yellow', 'Red'가 데이터로 저장돼 있습니다.

![image](https://user-images.githubusercontent.com/84713532/197480431-5896142f-bdaf-4cde-9246-35a05bf5d1a6.png)

---

2. 데이터는 연속된 메모리 영역에 순서대로 저장됩니다. 연속된 영역에 저장돼 있어서 첨자를 사용해서 메모리의 주소를 계산할 수 있습니다. 따라서 각 데이터에 바로 접근할 수 있습니다. 
이것을 '임의 접근(random access)'이라고 합니다. 예를 들어 'Red'에 접근하고 싶다면 포인터는 앞에서부터 따라가야 하지만, 배열의 경우는 a[2]라고 지정하기만 하면 직접 'Red'에 접근할 수 있습니다.

![image](https://user-images.githubusercontent.com/84713532/197480517-164daca4-ddd8-443c-a139-12e316c16968.png)

---

3. 배열은 임의의 위치에 데이터를 추가, 삭제해야하는 경우에 리스트에 비해 많은 시간이 걸리는 단점이 있습니다. 예를 들어, 'Green'을 두 번째 요소(a[1])에 추가하는 경우를 생각해 봅시다.
먼저, 배열의 마지막에 추가를 위한 공간을 확보하고 공간이 비는 곳으로 하나씩 데이터를 옆으로 이동시킵니다. 'Red' -> 'Yellow' 순으로 이동시킨 후 빈 공간에 'Green'을 추가합니다.

![image](https://user-images.githubusercontent.com/84713532/197480564-08bcd71b-6eeb-4be3-b31c-e94de171d240.png)

---

4. 반대로 'Green'을 삭제할 때는 먼저 요소를 삭제하고 빈 곳을 하나씩 메꾸면서 옮깁니다. 'Yellow' -> 'Red' 순으로 이동합니다. 마지막으로 남은 공간을 삭제함으로써 'Green' 삭제 작업을 완료합니다.

![image](https://user-images.githubusercontent.com/84713532/197480631-211ce869-7dde-4590-9cdb-6900a5ca7206.png)

---

### 배열의 계산, 추가, 삭제 시간

배열에 저장된 데이터의 수를 n이라고 하면 임의 접근을 할 수 있으므로(메모리 주소를 첨자를 통해 게산할 수 있으므로), 상수 O(1)의 계산 시간으로 데이터에 접근할 수 있습니다.
반면, 데이터를 추가할 때는 추가할 곳보다 뒤에 있는 모든 데이터를 하나씩 옮겨야 합니다. 배열의 선두에 데이터를 추가하려고 하면 O(n) 시간이 걸립니다. 삭제도 마찬가지입니다.

---

### 리스트와 배열 대조

리스트와 배열 모두 데이터를 1열로 나열하는 데이터 구조이지만, 리스트는 접근에 시간이 걸리는 반면에 추가나 삭제가 간단합니다. 반대로, 배열은 접근은 간단하지만 추가나 삭제에 많은 시간이 걸립니다.
무엇을 사용할지는 어떤 작업을 자주하는지를 고려해서 정하면 됩니다.

|     | 접근 | 추가 | 삭제 |
| --- | --- | --- | ---|
| 리스트 | 느림 | 빠름 | 빠름 |
| 배열 | 빠름 | 느림 | 느림 |
