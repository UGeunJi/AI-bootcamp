### 💠 입력 크기와 계산 시간과의 관계 이해하기
알고리즘의 실행 시간은 같은 알고리즘이라도 입력 값에 따라 크게 달라집니다.
예를 들어, 10개의 숫자를 정렬하는 것과1,000,000개의 숫자를 정렬하는 경우 후자가 더 많은 시간이 걸린다는 것을 예상할 수 있습니다. 하지만 실제로 어느 정도의 시간 차이가 발생할까요?
이처럼 알고리즘 간 실행 시간의 차이뿐만 아니라 같은 알고리즘에서도 입력의 크기에 따라 알고리즘 계산 시간이 얼마큼 달라지는지도 고려해야 합니다.

### 💠계산 시간 구하는 법
실제로 프로그램을 작성해서 컴퓨터에서 실행해 보고 실제로 걸리는 시간을 계측하는 것이 가장 현실적입니다. 하지만 이 방법으로는 같은 알고리즘이라도 사용하는 컴퓨터에 따라 계산 시간이 달라지므로 불편합니다.
따라서 계산 시간에는 '스탭 수'를 활용합니다. '1 스텝'은 계산의 기본 단위로, '계산을 종료하기까지 기본 단위를 몇 회 실행했는가'로 계산 시간을 측정합니다.

#### 예시: 선택 정렬의 계산 시간

1. 수열에서 최솟값을 찾는다.
2. 최솟값을 수열의 가장 왼쪽 숫자와 교환하고 정렬을 끝낸다. (1)로 돌아간다.

수열의 숫자 개수를 n이라고 하면 (1)의 '최솟값을 찾는다' 프로세스는 n개의 숫자를 확인하면 끝납니다. 여기서 '하나의 숫자를 확인한다'는 조작을 기본 단위로 생각하고 이때 걸리는 시간을
$T_c$라고 하면, (1)은 $n \times T_c$ 시간에 끝납니다.

계속해서 '두 개의 숫자를 교환한다'라는 조작도 기본 단위로 $T_s$시간이 걸린다고 합시다. (2)의 프로세스에서는 n과 관계없이 교환을 한 번만 하므로 $T_s$시간에 끝납니다. (1)과 (2)는
n회 반복하고 1회의 라운드마다 확인할 숫자가 하나씩 줄어드므로 전체 계산 시간은 다음이 됩니다.

---


$(n \times T_c + T_s) + ((n - 1) \times T_c + T_s) + ((n - 2) \times T_c + T_s) + \cdots + (2 \times T_c + T_s) + (1 \times T_c + T_s)$


등차수열 공식: l = a + (n - 1)d

$T_c + T_s + (n - 1)T_c = T_c + T_s +T_c n - T_c = T_s + T_c n$


등차수열의 합 공식: ${n(a + l) \over 2}$

${n(T_c + T_s + T_s + T_c n)} \over 2$
$={1 \over 2}n (2T_s + (n + 1)T_c)$
$={1 \over 2}n(n+1)T_c+2T_s n$

$= {1 \over 2}  T_c n(n + 1)+T_s n$

$= {1 \over 2} T_c n^2 +({1 \over 2} T_c + T_s)n$

---

### 💠계산 시간을 표현하는 방법
위 결과를 더 간략화
$T_c$와 $T_s$는 기본 단위로 입력과는 무관합니다. 입력에 의해 바뀌는 것은 수열의 길이인 n이므로 n을 크게 한 경우를 생각해 보겠습니다.
n을 크게 하면 크게 할수록 위 식에서 $n^2$ 부분이 매우 커지며 다른 부분은 상대적으로 작아집니다. 즉, 식에서 가장 큰 영향을 주는 부분은 $n^2$이라는 것을 알 수 있습니다.
따라서 다른 부분을 삭제해서 이 식을 다음과 같이 표현합니다.

$= {1 \over 2} T_c n^2 +({1 \over 2} T_c + T_s)n = O(n^2)$

이를 통해 선택 정렬의 실행 시간은 대략적으로 입력 수열의 크기 n의 2승만큼 비례해서 바뀐다는 것을 알 수 있습니다.

마찬가지로, 아래와 같은 예시의 알고리즘 계산량은 다음과 같습니다.

$5 T_x n^3 + 12T_y n^2 + 3T_z n \to O(n^3) $

$3n \log\ n + 2T_y n \to O(n \log\ n)$

O는 '중요한 항목 이외는 무시한다'라는 의미를 가지는 기호입니다. O는 '오더(order)' 또는 '빅오(Big O)'라고 읽습니다.
$O(n^2)$는 '계산 시간이 최악인 경우 $n^2$의 배수가 된다'는 것을 의미하지만 정확한 의미는 전문 서적을 참고해야 한다.
이 표기에 따라 알고리즘의 계산 시간을 직관적으로 이해할 수 있습니다.

예를 들어, 선택 정렬의 계산 시간이 $O(n^2)$이며 퀵 정렬(quick sort)의 계산 시간이 $O(n \ log \ n)$라는 정보가 주어진 경우, 퀵 정렬의 계산 시간이 빠르다는 것을 바로 알 수 있습니다.
또한, 입력의 크기 n의 변화에 따라 계산 시간이 어느 정도 달라지는지도 한눈에 파악할 수 있습니다.
