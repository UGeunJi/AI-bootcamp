#### 퀵 정렬(quick sort)에서는 기준이 되는 수(pivot)를 수열 안에서 임의로 하나를 선택합니다. 그리고 피봇 이외의 수를 '피봇보다 작은 수'와 '피봇 이상인 수'의 두 그룹으로 나누고 이것을 다음과 같이 배치합니다.

### 원리

1. 피봇을 수열 안에서 임의로 하나를 선택합니다.

2. 피봇 이외의 각 숫자를 피봇과 비교하며 피봇보다 작으면 왼쪽, 크면 오른쪽으로 이동합니다.

3. 각각의 정렬이 순서대로 되지 않았다면 (1)~(2) 과정을 반복하며 정렬을 완료합니다.

### 보충

퀵 정렬은 '분할병합법'의 일종입니다. 원래의 문제를 두 개의 자식 문제(피봇보다 작은 것과 피봇 이상인 것)으로 분할하고 두 개의 자식 문제를 각각 해결합니다. 각 자식 문제가 정렬 완료 상태가 되면 처음에 설명한
것처럼 각각을 단순히 붙이기만 하면(병합) 원래 수열을 정렬한 결과를 얻을 수 있습니다.

참고로, 이 자식 문제를 해결하는 부분에도 퀵 정렬이 사용되며, 이 퀵 정렬 안에서도 다시 퀵 정렬이 사용됩니다. 자식 문제에 숫자가 하나만 남으면 정렬이 끝납니다.

이처럼 알고리즘의 내부에 알고리즘 자신을 적용하는 것을 '재귀(recursive)'라고 합니다. 재귀에 대해서는 7-4절에서도 설명합니다. 사실은 앞 절에서 본 병합 정렬도 재귀를 사용한 분할병합법이라고 볼 수 있습니다.

### 계산 시간

자식 문제를 만들기 위해 피봇을 선택하지만, 두 개의 자식 문제가 원래 문제의 반이 되도록 매번 피봇을 선택해 가면 퀵 정렬의 계산 시간은 병합 정렬과 같은 O( $n \log {n}$)이 됩니다.
이것은 병합 정렬과 마찬가지로 자식 문제의 크기가 반이 되는 과정을 $\log_{2}{n}$회 반복하면 요소가 하나의 자식 문제가 돼서 정렬이 완료되기 때문입니다.
따라서 피봇을 통해 숫자를 분할하는 과정을 다음 그림과 같이 한 단계씩 그리면 전체적으로 $\log_{2}{n}$층이 됩니다.

![image](https://user-images.githubusercontent.com/84713532/197927826-d4aabbbc-f972-40e5-8060-3d6ae83c44c3.png)

![image](https://user-images.githubusercontent.com/84713532/197928075-944cb34f-fc2c-4f2f-b8f7-79182c3a31bd.png)

또한, 각 층에서 각 숫자는 피봇과 1회만 비교되므로 한 층의 계산 시간은 O(n)이 됩니다. 따라서 전체 계산 시간은 O( $n \log {n}$)이 되는 것입니다.

반면, 운이 나빠 매번 최솟값이 피봇으로 선택되면 모든 숫자가 피봇보다 오른쪽으로 가기 때문에 재귀가 n층이 돼서 계산 시간이 O( $n^2$)가 됩니다.
이것은 매번 최솟값이 선두로 나오므로 선택 정렬과 같은 처리가 됩니다. 참고로, 피봇을 대상 숫자 안에서 동등 확률로 선택하면 평균적으로 O( $n \log {n}$)의 계산 시간이 걸린다고 알려져 있습니다.
